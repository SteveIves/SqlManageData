;-------------------------------------------------------------------------------
;Routine:       initialize_database
;
;Description:   create a connection to the SQL Server database
;
.function initialize_database, ^VAL

;Add SQL Connection include file
.include "CONNECTDIR:ssql.def"

;Include application global data
.define TKAPP_INCLUDE
.include "SRC:tkapp.dbl"

;Define constants
.define D_BUFSIZ    2048
.define D_MAX_CUR   16
.define D_MAX_COL   250

.define SQL_SERVER      "LOCALHOST"             ;Host name or IP address
.define SQL_DATABASE    "SqlManagement"         ;Database name
.define SQL_USERNAME    "SqlManagement"         ;SQL Server username
.define SQL_PASSWORD    "SqlManagementPassword" ;Password

;Declare local variables
stack record ivars
    sts             ,i4     ;Database error status
    len             ,i4     ;Length of error message

stack record avars
    msg             ,a255   ;Error details
    connect_string  ,a128   ;Database connection string

stack record options        ;Database options
    date_base       ,d6
    date_format     ,a64
    null_mask       ,d3

.proc

    ;Initialize local data
    clear ^i(ivars), avars, options

    ;Enable SQL Connection API
    len = %option(48,1)

    ;Connect to the database
    if(TRUE)
    begin
        if (sts=%ssc_init(iddb_channel=1,D_MAX_CUR,D_MAX_COL,D_BUFSIZ)
        &   .ne. SSQL_NORMAL) exit

        ;connect_string="VTX12_SQLNATIVE://SqlManagement/.\\SQLEXPRESS///Trusted_connection=yes"
        connect_string="VTX12_SQLNATIVE://SqlManagement/.///Trusted_connection=yes"

        if (sts=%ssc_connect(iddb_channel,connect_string)
        &   .ne. SSQL_NORMAL) exit

        ;Date format
        if (sts=%ssc_option(iddb_channel,SSQL_GETOPT,date_base,
        &   date_format,null_mask) .ne. SSQL_NORMAL) exit

        date_format="YYYYMMDD"  ;Define the right format

        if (sts=%ssc_option(iddb_channel,SSQL_SETOPT,date_base,
        &   date_format,null_mask) .ne. SSQL_NORMAL) exit
    end

    ;Check for database connection error
    if (sts)
    begin
        xcall ssc_getemsg(iddb_channel,msg,len)
        xcall u_message(msg(1:len))
        ;Record the error in the Windows Event Log
        xcall syn_reportevent(D_EVENTLOG_ERROR_TYPE,msg)
    end

    ;Return status to calling routine
    freturn (.not.sts)

.end

;-------------------------------------------------------------------------------
;Routine:       create_customer
;
;Description:   Create a new customer record
;
.function create_customer, ^val

    .include "CUSTOMER" repository, group="customer"
    ;End of parameters

.define TKAPP_INCLUDE
.include "SRC:tkapp.dbl"

.include 'CONNECTDIR:ssql.def'

;internal variables
.align
stack record ivars
    sts         ,i4     ;database error flag

stack record avars
    msg,        a255    ;database error message

;Define the insert command
.define D_INSERT_CUSTOMER "INSERT INTO CUSTOMER("
&   + "ACCOUNT,"
&   + "COMPANY,"
&   + "STREET_NUMBER,"
&   + "STREET,"
&   + "CITY,"
&   + "REGION,"
&   + "POSTAL_CODE,"
&   + "COUNTRY,"
&   + "PHONE_COUNTRY,"
&   + "PHONE_AREA,"
&   + "PHONE_NUMBER,"
&   + "FAX_AREA,"
&   + "FAX_NUMBER,"
&   + "MOBILE_AREA,"
&   + "MOBILE_NUMBER,"
&   + "PAGER_AREA,"
&   + "PAGER_NUMBER,"
&   + "EMAIL1,"
&   + "EMAIL2,"
&   + "DATE_OPENED,"
&   + "DATE_HOLD,"
&   + "DATE_CLOSED,"
&   + "STATUS,"
&   + "LIMIT,"
&   + "BALANCE,"
&   + "CARD_NUMBER,"
&   + "CARD_EXPIRY,"
&   + "CARD_NAME)"

.define D_CUSTOMER_VALUES " VALUES(:1,:2,:3,:4,:5,:6,:7,:8"
&   + ",:9,:10,:11,:12,:13,:14,:15,:16,:17"
&   + ",:18,:19,:20,:21,:22,:23,:24,:25,:26,:27,:28)"

.proc

    clear ^i(ivars), avars

    if (TRUE)
    begin
        ;Open a cursor
        if (sts=%ssc_open(iddb_channel, idf_customer,
        &   D_INSERT_CUSTOMER + D_CUSTOMER_VALUES,
        &   SSQL_NONSEL,SSQL_STANDARD) .ne. SSQL_NORMAL) exit

        ;Bind variables to the command
        if (sts=%ssc_bind(iddb_channel, idf_customer, 28
        &   ,customer.account
        &   ,customer.company
        &   ,customer.number
        &   ,customer.street
        &   ,customer.city
        &   ,customer.region
        &   ,customer.postal_code
        &   ,customer.country
        &   ,customer.phone_country
        &   ,customer.phone_area
        &   ,customer.phone_number
        &   ,customer.fax_area
        &   ,customer.fax_number
        &   ,customer.mobile_area
        &   ,customer.mobile_number
        &   ,customer.pager_area
        &   ,customer.pager_number
        &   ,customer.email1
        &   ,customer.email2
        &   ,^a(customer.date_opened)
        &   ,^a(customer.date_hold)
        &   ,^a(customer.date_closed)
        &   ,customer.status
        &   ,customer.limit
        &   ,customer.balance
        &   ,customer.card_number
        &   ,customer.card_expiry
        &   ,customer.card_name) .ne. SSQL_NORMAL) exit

        ;Start a transaction
        if (sts=%ssc_commit(iddb_channel, SSQL_TXON).ne. SSQL_NORMAL) exit

        ;Check date values
        if (.not.date_opened)
            ^a(date_opened(1:1)) = %char(0)
        if (.not.date_hold)
            ^a(date_hold(1:1)) = %char(0)
        if (.not.date_closed)
            ^a(date_closed(1:1)) = %char(0)
        if (.not.card_expiry)
            ^a(card_expiry(1:1)) = %char(0)

        ;Execute the bound command
        if (sts=%ssc_execute(iddb_channel, idf_customer,
        &    SSQL_STANDARD) .ne. SSQL_NORMAL) exit

        ;Hard close the cursor
        if (sts=%ssc_close(iddb_channel, idf_customer).ne.SSQL_NORMAL) exit

        ;Commit the transaction
        if (sts=%ssc_commit(iddb_channel, SSQL_TXOFF).ne.SSQL_NORMAL) exit

    end

    ;Report any error
    if (sts)
    begin
        xcall ssc_getemsg(iddb_channel, msg, sts)
        xcall u_message(msg(1:sts))
        xcall syn_reportevent(D_EVENTLOG_ERROR_TYPE, msg)
    end

    freturn (.not.sts)

.end

;-------------------------------------------------------------------------------
;Routine:       create_group
;
;Description:   Create a new product group record
;
.function create_group, ^val

    .include "PRODUCT_GROUP" repository, group="product_group"
    ;End of parameters

.define TKAPP_INCLUDE
.include "SRC:tkapp.dbl"

.include 'CONNECTDIR:ssql.def'

;internal variables
.align
stack record ivars
    sts         ,i4     ;database error flag

stack record avars
    msg,        a255    ;database error message

;define the insert command
.define D_INSERT_GROUP "INSERT INTO PRODUCT_GROUP("
&       + "NAME,"
&       + "DESCRIPTION)"

.define D_GROUP_VALUES " VALUES(:1,:2)"

.proc

    clear ^i(ivars), avars

    ;logic to perform INSERT command

    if (TRUE)
    begin
        ;open a cursor
        if (sts=%ssc_open(iddb_channel, idf_group ,
        &   D_INSERT_GROUP + D_GROUP_VALUES,
        &   SSQL_NONSEL,SSQL_STANDARD) .ne. SSQL_NORMAL) exit

        ;bind the command
        if (sts=%ssc_bind(iddb_channel, idf_group, 2
        &   ,product_group.name
        &   ,product_group.description) .ne. SSQL_NORMAL) exit

        ;start a transaction
        if (sts=%ssc_commit(iddb_channel, SSQL_TXON)  .ne.  SSQL_NORMAL) exit

        ;execute the bound command
        if (sts=%ssc_execute(iddb_channel, idf_group,
        &   SSQL_STANDARD) .ne. SSQL_NORMAL) exit

        ;hard close the idf_customer
        if (sts=%ssc_close(iddb_channel, idf_group) .ne. SSQL_NORMAL) exit

        ;commit the transaction
        if (sts=%ssc_commit(iddb_channel,SSQL_TXOFF) .ne. SSQL_NORMAL) exit

    end

    if (sts)
    begin
        xcall ssc_getemsg(iddb_channel, msg, sts)
        xcall u_message(msg(1:sts))
        xcall syn_reportevent(D_EVENTLOG_ERROR_TYPE, msg)
    end

    freturn (.not.sts)

.end

;-------------------------------------------------------------------------------
;Routine:       create_product
;
;Description:   Create a new product record
;
.function create_product, ^val

    .include "PRODUCT" repository, group="product"
    ;End of parameters

.define TKAPP_INCLUDE
.include "SRC:tkapp.dbl"

.include 'CONNECTDIR:ssql.def'

;internal variables
.align
stack record ivars
    sts         ,i4     ;database error flag

stack record avars
    msg,        a255    ;database error message

;define the insert command
.define D_INSERT_PRODUCT "INSERT INTO PRODUCT("
&       + "SKU,"
&       + "PRODUCT_GROUP,"
&       + "DESCRIPTION,"
&       + "PRICE_GROUP,"
&       + "SELLING_PRICE,"
&       + "LAST_SALE,"
&       + "LAST_COST_PRICE,"
&       + "MOVING_AVE_COST_PRICE,"
&       + "QTY_IN_STOCK,"
&       + "QTY_ALLOCATED,"
&       + "QTY_IN_TRANSIT,"
&       + "QTY_ON_ORDER,"
&       + "REFERENCE,"
&       + "PUBLISHER,"
&       + "AUTHOR,"
&       + "PRODUCT_TYPE,"
&       + "RELEASE_DATE,"
&       + "RATING)"

.define D_PRODUCT_VALUES " VALUES(:1,:2,:3,:4,:5,:6,:7,:8,:9,:10"
&       + ",:11,:12,:13,:14,:15,:16,:17,:18)"
.proc

    clear ^i(ivars), avars

    ;logic to perform INSERT command

    if (TRUE)
    begin
        ;open a cursor
        if (sts=%ssc_open(iddb_channel, idf_product ,
        &   D_INSERT_PRODUCT + D_PRODUCT_VALUES,
        &   SSQL_NONSEL,SSQL_STANDARD) .ne. SSQL_NORMAL) exit

        ;bind the command
        if (sts=%ssc_bind(iddb_channel, idf_product, 18
        &   ,sku
        &   ,group
        &   ,description
        &   ,price_group
        &   ,selling_price
        &   ,last_sale
        &   ,last_cost_price
        &   ,moving_ave_cost_price
        &   ,qty_in_stock
        &   ,qty_allocated
        &   ,qty_in_transit
        &   ,qty_on_order
        &   ,reference
        &   ,publisher
        &   ,author
        &   ,type
        &   ,release_date
        &   ,rating) .ne. SSQL_NORMAL) exit

        ;start a transaction
        if (sts=%ssc_commit(iddb_channel, SSQL_TXON)  .ne.  SSQL_NORMAL) exit

        ;Check date values
        if (.not.last_sale)
            ^a(last_sale(1:1)) = %char(0)
        if (.not.release_date)
            ^a(release_date(1:1)) = %char(0)

        ;execute the bound command
        if (sts=%ssc_execute(iddb_channel, idf_product,
        &   SSQL_STANDARD) .ne. SSQL_NORMAL) exit

        ;hard close the idf_customer
        if (sts=%ssc_close(iddb_channel, idf_product) .ne. SSQL_NORMAL) exit

        ;commit the transaction
        if (sts=%ssc_commit(iddb_channel,SSQL_TXOFF) .ne. SSQL_NORMAL) exit

    end

    if (sts)
    begin
        xcall ssc_getemsg(iddb_channel, msg, sts)
        xcall u_message(msg(1:sts))
        xcall syn_reportevent(D_EVENTLOG_ERROR_TYPE, msg)
    end

    freturn (.not.sts)

.end

;-------------------------------------------------------------------------------
;Routine:       create_user
;
;Description:   Create a new user record
;
.function create_user, ^val

    .include "USER" repository, group="user"
    ;End of parameters

.define TKAPP_INCLUDE
.include "SRC:tkapp.dbl"

stack record ivars
    sts         ,i4     ;database error

stack record avars
    msg             ,a255   ;database error message

;define the insert command
.define D_INSERT_USERTABLE "INSERT INTO USERTABLE("
    &       + "USERNAME,"
    &       + "FIRST_NAME,"
    &       + "LAST_NAME,"
    &       + "PASSWORD,"
    &       + "USER_CUSTOMER,"
    &       + "PHONE_AREA,"
    &       + "PHONE_NUMBER,"
    &       + "EMAIL)"

.define D_USERTABLE_VALUES " VALUES(:1,:2,:3,:4,:5,:6,:7,:8)"

.proc

    clear ^i(ivars), avars

    ;logic to perform INSERT command

    if (TRUE)
    begin
        ;open a cursor
        if (sts=%ssc_open(iddb_channel, idf_user ,
        &   D_INSERT_USERTABLE + D_USERTABLE_VALUES,
        &   SSQL_NONSEL,SSQL_STANDARD) .ne. SSQL_NORMAL) exit

        ;bind the command
        if (sts=%ssc_bind(iddb_channel, idf_user, 8
        &   ,user.username
        &   ,user.first_name
        &   ,user.last_name
        &   ,user.password
        &   ,user.user_customer
        &   ,user.phone_area
        &   ,user.phone_number
        &   ,user.email) .ne. SSQL_NORMAL) exit

        ;start a transaction
        if (sts=%ssc_commit(iddb_channel, SSQL_TXON)  .ne.  SSQL_NORMAL) exit

        ;execute the bound command
        if (sts=%ssc_execute(iddb_channel, idf_user,
        &   SSQL_STANDARD) .ne. SSQL_NORMAL) exit

        ;hard close the cursor
        if (sts=%ssc_close(iddb_channel, idf_user) .ne. SSQL_NORMAL) exit

        ;commit the transaction
        if (sts=%ssc_commit(iddb_channel,SSQL_TXOFF) .ne. SSQL_NORMAL) exit

    end

    if (sts)
    begin
        xcall ssc_getemsg(iddb_channel, msg, sts)
        xcall u_message(msg(1:sts))
        xcall syn_reportevent(D_EVENTLOG_ERROR_TYPE, msg)
    end

    freturn (.not.sts)

.end

;-------------------------------------------------------------------------------
;Routine:       delete_customer
;
;Description:   Delete a customer record
;
.function delete_customer, ^val

    a_account   ,a  ;Account to be deleted
    ;End of parameters

.define TKAPP_INCLUDE
.include "SRC:tkapp.dbl"

stack record ivars
    sts         ,i4

stack record avars
    msg             ,a255   ;database error message

;Define the delete statement
.define D_DELETE_CUSTOMER "DELETE CUSTOMER WHERE ACCOUNT=:1"

.proc

    clear ^i(ivars), avars

    if(TRUE)
    begin
        ;Open a cursor
        if (sts=%ssc_open(iddb_channel, idf_customer, D_DELETE_CUSTOMER,
        &    SSQL_NONSEL, SSQL_STANDARD, 1, a_account) .ne. SSQL_NORMAL) exit

        ;Start a transaction
        if (sts=%ssc_commit(iddb_channel, SSQL_TXON) .ne. SSQL_NORMAL) exit

        ;Execute the bound command
        if (sts=%ssc_execute(iddb_channel, idf_customer,
        &    SSQL_STANDARD) .ne. SSQL_NORMAL) exit

        ;Hard close the cursor
        if (sts=%ssc_close(iddb_channel, idf_customer).ne.SSQL_NORMAL) exit

        ;Commit the transaction
        if (sts=%ssc_commit(iddb_channel,SSQL_TXOFF) .ne. SSQL_NORMAL) exit

    end

    ;Report any error
    if (sts)
    begin
        xcall ssc_getemsg(iddb_channel, msg, sts)
        xcall u_message(msg(1:sts))
        xcall syn_reportevent(D_EVENTLOG_ERROR_TYPE, msg)
    end

    freturn (.not.sts)

.end

;-------------------------------------------------------------------------------
;Routine:       delete_group
;
;Description:   Delete a group record
;
.function delete_group, ^val

    a_group ,a  ;Group to be deleted
    ;End of parameters

.define TKAPP_INCLUDE
.include "SRC:tkapp.dbl"

stack record ivars
    sts         ,i4

stack record avars
    msg             ,a255   ;database error message

.define D_DELETE_GROUP "DELETE PRODUCT_GROUP WHERE NAME=:1"

.proc

    clear ^i(ivars), avars

    if(TRUE)
    begin
        ;open a cursor
        if (sts=%ssc_open(iddb_channel, idf_group ,
        &   D_DELETE_GROUP,
        &   SSQL_NONSEL,SSQL_STANDARD,
        &   1, a_group) .ne. SSQL_NORMAL) exit

        ;start a transaction
        if (sts=%ssc_commit(iddb_channel, SSQL_TXON)  .ne.  SSQL_NORMAL) exit

        ;execute the bound command
        if (sts=%ssc_execute(iddb_channel, idf_group,
        &   SSQL_STANDARD) .ne. SSQL_NORMAL) exit

        ;hard close the cursor
        if (sts=%ssc_close(iddb_channel, idf_group) .ne. SSQL_NORMAL) exit

        ;commit the transaction
        if (sts=%ssc_commit(iddb_channel,SSQL_TXOFF) .ne. SSQL_NORMAL) exit

    end

    if (sts)
    begin
        xcall ssc_getemsg(iddb_channel, msg, sts)
        xcall u_message(msg(1:sts))
        xcall syn_reportevent(D_EVENTLOG_ERROR_TYPE, msg)
    end

    freturn (.not.sts)

.end

;-------------------------------------------------------------------------------
;Routine:       delete_product
;
;Description:   Delete a product record
;
.function delete_product, ^val

    a_sku   ,a  ;Product to be deleted
    ;End of parameters

.define TKAPP_INCLUDE
.include "SRC:tkapp.dbl"

stack record ivars
    sts         ,i4

stack record avars
    msg             ,a255   ;database error message

.define D_DELETE_PRODUCT "DELETE PRODUCT WHERE SKU=:1"

.proc

    clear ^i(ivars), avars

    if(TRUE)
    begin
        ;open a cursor
        if (sts=%ssc_open(iddb_channel, idf_product ,
        &   D_DELETE_PRODUCT,
        &   SSQL_NONSEL,SSQL_STANDARD,
        &   1, a_sku) .ne. SSQL_NORMAL) exit

        ;start a transaction
        if (sts=%ssc_commit(iddb_channel, SSQL_TXON)  .ne.  SSQL_NORMAL) exit

        ;execute the bound command
        if (sts=%ssc_execute(iddb_channel, idf_product,
        &   SSQL_STANDARD) .ne. SSQL_NORMAL) exit

        ;hard close the cursor
        if (sts=%ssc_close(iddb_channel, idf_product) .ne. SSQL_NORMAL) exit

        ;commit the transaction
        if (sts=%ssc_commit(iddb_channel,SSQL_TXOFF) .ne. SSQL_NORMAL) exit

    end

    if (sts)
    begin
        xcall ssc_getemsg(iddb_channel, msg, sts)
        xcall u_message(msg(1:sts))
        xcall syn_reportevent(D_EVENTLOG_ERROR_TYPE, msg)
    end

    freturn (.not.sts)

.end

;-------------------------------------------------------------------------------
;Routine:       delete_user
;
;Description:   Delete a user record
;
.function delete_user, ^val

    a_username  ,a  ;Account to be deleted
    ;End of parameters

.define TKAPP_INCLUDE
.include "SRC:tkapp.dbl"

stack record ivars
    sts         ,i4

stack record avars
    msg             ,a255   ;database error message

.define D_DELETE_USER "DELETE USERTABLE WHERE USERNAME=:1"

.proc

    clear ^i(ivars), avars

    if(TRUE)
    begin
        ;open a cursor
        if (sts=%ssc_open(iddb_channel, idf_user ,
        &   D_DELETE_USER,
        &   SSQL_NONSEL,SSQL_STANDARD,
        &   1, a_username) .ne. SSQL_NORMAL) exit

        ;start a transaction
        if (sts=%ssc_commit(iddb_channel, SSQL_TXON)  .ne.  SSQL_NORMAL) exit

        ;execute the bound command
        if (sts=%ssc_execute(iddb_channel, idf_user,
        &   SSQL_STANDARD) .ne. SSQL_NORMAL) exit

        ;hard close the cursor
        if (sts=%ssc_close(iddb_channel, idf_user) .ne. SSQL_NORMAL) exit

        ;commit the transaction
        if (sts=%ssc_commit(iddb_channel,SSQL_TXOFF) .ne. SSQL_NORMAL) exit

    end

    if (sts)
    begin
        xcall ssc_getemsg(iddb_channel, msg, sts)
        xcall u_message(msg(1:sts))
        xcall syn_reportevent(D_EVENTLOG_ERROR_TYPE, msg)
    end

    freturn (.not.sts)

.end

;-------------------------------------------------------------------------------
;Routine:       find_customer
;
;Description:   Locate a customer record
;
.function find_customer, ^val

    a_account   ,a      ;(Optional) account number to find
    .include "CUSTOMER" repository, group="a_customer"
    ;End of parameters

.define TKAPP_INCLUDE
.include "SRC:tkapp.dbl"

stack record ivars
    sts         ,i4         ;status

stack record avars
    msg         ,a255       ;database error message

;Define the SELECT statements
.define D_SEL_CUSTOMER "SELECT * FROM CUSTOMER"
.define D_SEL_CUSTOMER_BYKEY "SELECT * FROM CUSTOMER WHERE ACCOUNT=:1"

.proc

    clear ^i(ivars), avars

    if(TRUE)
    begin
        ;Open a cursor
        if (^passed(a_account) .and. a_account) then
            if (sts=%ssc_open(iddb_channel, idf_customer, D_SEL_CUSTOMER_BYKEY,
            &   SSQL_SELECT, SSQL_STANDARD, 1, a_account) .ne. SSQL_NORMAL) exit
        else
            if (sts=%ssc_open(iddb_channel, idf_customer, D_SEL_CUSTOMER,
            &   SSQL_SELECT, SSQL_STANDARD) .ne. SSQL_NORMAL) exit

        ;Define the Synergy variables
        if (sts=%ssc_define(iddb_channel, idf_customer, 28
        &   ,a_customer.account
        &   ,a_customer.company
        &   ,a_customer.number
        &   ,a_customer.street
        &   ,a_customer.city
        &   ,a_customer.region
        &   ,a_customer.postal_code
        &   ,a_customer.country
        &   ,a_customer.phone_country
        &   ,a_customer.phone_area
        &   ,a_customer.phone_number
        &   ,a_customer.fax_area
        &   ,a_customer.fax_number
        &   ,a_customer.mobile_area
        &   ,a_customer.mobile_number
        &   ,a_customer.pager_area
        &   ,a_customer.pager_number
        &   ,a_customer.email1
        &   ,a_customer.email2
        &   ,^a(a_customer.date_opened)
        &   ,^a(a_customer.date_hold)
        &   ,^a(a_customer.date_closed)
        &   ,a_customer.status
        &   ,a_customer.limit
        &   ,a_customer.balance
        &   ,a_customer.card_number
        &   ,a_customer.card_expiry
        &   ,a_customer.card_name) .ne. SSQL_NORMAL) exit

        ;Check if we should retrieve the row
        if (^passed(a_account) .and. a_account)
        begin
            using (sts=%ssc_move(iddb_channel, idf_customer)) select
            (SSQL_NORMAL),
                sts=FALSE   ;Reverts to true on exit!
            (),
                sts=TRUE    ;Force an error
            endusing
            xcall ssc_close(iddb_channel, idf_customer)
        end

    end

    freturn (.not.sts)

.end

;-------------------------------------------------------------------------------
;Routine:       find_group
;
;Description:   Locate a group record
;
.function find_group, ^val

    a_group     ,a      ;(Optional) product group name to find
    .include "product_group" repository, group="product_group"
    ;End of parameters

.define TKAPP_INCLUDE
.include "SRC:tkapp.dbl"

stack record ivars
    sts         ,i4

stack record avars
    msg         ,a255       ;database error message

.define D_SELECT_GROUP "SELECT * FROM PRODUCT_GROUP"
.define D_SELECT_GROUP_WITHKEY "SELECT * FROM PRODUCT_GROUP WHERE NAME=:1"

.proc

    clear ^i(ivars), avars

    if(TRUE)
    begin
        ;open a cursor
        If (^passed(a_group) .and. a_group)
        then
            if (sts=%ssc_open(iddb_channel, idf_group ,
            &   D_SELECT_GROUP_WITHKEY ,
            &   SSQL_SELECT, SSQL_STANDARD,
            &   1, a_group) .ne. SSQL_NORMAL) exit
        else
            if (sts=%ssc_open(iddb_channel, idf_group ,
            &   D_SELECT_GROUP ,
            &   SSQL_SELECT, SSQL_STANDARD) .ne. SSQL_NORMAL) exit

        ;bind the command
        if (sts=%ssc_define(iddb_channel, idf_group, 2
        &   ,product_group.name
        &   ,product_group.description) .ne. SSQL_NORMAL) exit

        if (^passed(a_group) .and. a_group)
        begin
            using (sts=%ssc_move(iddb_channel, idf_group)) select
            (SSQL_NORMAL),
                sts=FALSE   ;got a record, reverts to true on exit!
            (),
                sts=TRUE    ;force an error
            endusing
            ;hard close the cursor
            xcall ssc_close(iddb_channel, idf_group)
        end
    end

    freturn (.not.sts)

.end

;-------------------------------------------------------------------------------
;Routine:       find_product
;
;Description:   Locate a product record
;
.function find_product, ^val

    a_product   ,a      ;(Optional) product code to find
    a_keynum    ,n      ;(Optional) key number to use
    .include "product" repository, group="product"
    ;End of parameters

.define TKAPP_INCLUDE
.include "SRC:tkapp.dbl"

stack record ivars
    sts         ,i4

stack record avars
    command     ,a1000      ;command to execute when a key is passed.
    msg         ,a255       ;database error message

.define D_SELECT_PRODUCT "SELECT * FROM PRODUCT"
.define D_SELECT_PRODUCT_WITHKEY0 "SELECT * FROM PRODUCT WHERE SKU=:1"
.define D_SELECT_PRODUCT_WITHKEY1 "SELECT * FROM PRODUCT WHERE PRODUCT_GROUP=:1"
.define D_SELECT_PRODUCT_WITHKEY2 "SELECT * FROM PRODUCT WHERE DESCRIPTION=:1"
.define D_SELECT_PRODUCT_WITHKEY3 "SELECT * FROM PRODUCT WHERE PRICE_GROUP=:1"
.define D_SELECT_PRODUCT_WITHKEY4 "SELECT * FROM PRODUCT WHERE AUTHOR=:1"
.define D_SELECT_PRODUCT_WITHKEY5 "SELECT * FROM PRODUCT WHERE PUBLISHER=:1"
.define D_SELECT_PRODUCT_WITHKEY6 "SELECT * FROM PRODUCT WHERE REFERENCE=:1"

.proc

    clear ^i(ivars), avars

    if(TRUE)
    begin
        ;open a cursor
        If (^passed(a_product) .and. a_product)
        then
        begin
            if (^passed(a_keynum))
            begin
                using a_keynum select
                (0),
                    command = D_SELECT_PRODUCT_WITHKEY0
                (1),
                    command = D_SELECT_PRODUCT_WITHKEY1
                (2),
                    command = D_SELECT_PRODUCT_WITHKEY2
                (3),
                    command = D_SELECT_PRODUCT_WITHKEY3
                (4),
                    command = D_SELECT_PRODUCT_WITHKEY4
                (5),
                    command = D_SELECT_PRODUCT_WITHKEY5
                (6),
                    command = D_SELECT_PRODUCT_WITHKEY6
                endusing
                if (sts=%ssc_open(iddb_channel, idf_product ,
                &   command ,
                &   SSQL_SELECT, SSQL_STANDARD,
                &   1, a_product) .ne. SSQL_NORMAL) exit
            end
        end
        else
        begin
            if (sts=%ssc_open(iddb_channel, idf_product ,
            &   D_SELECT_PRODUCT ,
            &   SSQL_SELECT, SSQL_STANDARD) .ne. SSQL_NORMAL) exit
        end


        ;bind the command
        if (sts=%ssc_define(iddb_channel, idf_product, 18
        &   ,sku
        &   ,group
        &   ,description
        &   ,price_group
        &   ,selling_price
        &   ,last_sale
        &   ,last_cost_price
        &   ,moving_ave_cost_price
        &   ,qty_in_stock
        &   ,qty_allocated
        &   ,qty_in_transit
        &   ,qty_on_order
        &   ,reference
        &   ,publisher
        &   ,author
        &   ,type
        &   ,release_date
        &   ,rating) .ne. SSQL_NORMAL) exit

        if (^passed(a_product) .and. a_product)
        begin
            using (sts=%ssc_move(iddb_channel, idf_product)) select
            (SSQL_NORMAL),
                sts=FALSE   ;got a record, reverts to true on exit!
            (),
                sts=TRUE    ;force an error
            endusing
            ;hard close the cursor
            xcall ssc_close(iddb_channel, idf_product)
        end
    end

    freturn (.not.sts)

.end

;-------------------------------------------------------------------------------
;Routine:       find_user
;
;Description:   Locate a user record
;
.function find_user, ^val

    a_username  ,a      ;(Optional) username to find
    a_keynum    ,n      ;(Optional) key number to use
    .include "user" repository, group="user"
    ;End of parameters

.define TKAPP_INCLUDE
.include "SRC:tkapp.dbl"

stack record ivars
    sts         ,i4

stack record avars
    command     ,a1000      ;command to execute when a key is passed.
    msg         ,a255       ;database error message

.define D_SELECT_USER "SELECT * FROM USERTABLE"
.define D_SELECT_USER_WITHKEY0 "SELECT * FROM USERTABLE WHERE USERNAME=:1"
.define D_SELECT_USER_WITHKEY1 "SELECT * FROM USERTABLE WHERE USER_CUSTOMER=:1"

.proc

    clear ^i(ivars), avars

    if(TRUE)
    begin
        ;open a cursor
        If (^passed(a_username) .and. a_username)
        then
        begin
            if (^passed(a_keynum))
            begin
                using a_keynum select
                (0),
                    command = D_SELECT_USER_WITHKEY0
                (1),
                    command = D_SELECT_USER_WITHKEY1
                endusing
                if (sts=%ssc_open(iddb_channel, idf_user ,
                &   command ,
                &   SSQL_SELECT, SSQL_STANDARD,
                &   1, a_username) .ne. SSQL_NORMAL) exit
            end
        end
        else
        begin
            if (sts=%ssc_open(iddb_channel, idf_user ,
            &   D_SELECT_USER ,
            &   SSQL_SELECT, SSQL_STANDARD) .ne. SSQL_NORMAL) exit
        end


        ;bind the command
        if (sts=%ssc_define(iddb_channel, idf_user, 8
        &   ,user.username
        &   ,user.first_name
        &   ,user.last_name
        &   ,user.password
        &   ,user.user_customer
        &   ,user.phone_area
        &   ,user.phone_number
        &   ,user.email) .ne. SSQL_NORMAL) exit

        if (^passed(a_username) .and. a_username)
        begin
            using (sts=%ssc_move(iddb_channel, idf_user)) select
            (SSQL_NORMAL),
                sts=FALSE   ;got a record, reverts to true on exit!
            (),
                sts=TRUE    ;force an error
            endusing
            ;hard close the cursor
            xcall ssc_close(iddb_channel, idf_user)
        end
    end

    freturn (.not.sts)

.end

;-------------------------------------------------------------------------------
;Routine:       get_customer
;
;Description:   Read a customer record
;
.function get_customer, ^val

    .include "CUSTOMER" repository, group="a_customer"
    a_lock      ,n
;End of parameters

.define TKAPP_INCLUDE
.include "SRC:tkapp.dbl"

stack record ivars
    sts         ,i4

stack record avars
    msg         ,a255       ;database error message

;Define the SQL SELECT statement
.define D_GET_CUSTOMER "SELECT * FROM CUSTOMER WHERE ACCOUNT=:1"

.proc

    clear ^i(ivars), avars

    if(TRUE)
    begin
        ;Open a cursor
        if (sts=%ssc_open(iddb_channel, idf_customer, D_GET_CUSTOMER,
        &   SSQL_SELECT, SSQL_STANDARD, 1, a_customer.account)
        &   .ne. SSQL_NORMAL) exit

        ;Define the Synergy variables
        if (sts=%ssc_define(iddb_channel, idf_customer, 28
        &   ,a_customer.account
        &   ,a_customer.company
        &   ,a_customer.number
        &   ,a_customer.street
        &   ,a_customer.city
        &   ,a_customer.region
        &   ,a_customer.postal_code
        &   ,a_customer.country
        &   ,a_customer.phone_country
        &   ,a_customer.phone_area
        &   ,a_customer.phone_number
        &   ,a_customer.fax_area
        &   ,a_customer.fax_number
        &   ,a_customer.mobile_area
        &   ,a_customer.mobile_number
        &   ,a_customer.pager_area
        &   ,a_customer.pager_number
        &   ,a_customer.email1
        &   ,a_customer.email2
        &   ,^a(a_customer.date_opened)
        &   ,^a(a_customer.date_hold)
        &   ,^a(a_customer.date_closed)
        &   ,a_customer.status
        &   ,a_customer.limit
        &   ,a_customer.balance
        &   ,a_customer.card_number
        &   ,a_customer.card_expiry
        &   ,a_customer.card_name) .ne. SSQL_NORMAL) exit

        ;Retrieve the data
        using (sts=%ssc_move(iddb_channel, idf_customer)) select
        (SSQL_NORMAL),
            sts=FALSE   ;Reverts to true on exit!
        (SSQL_FAILURE, SSQL_NOMORE),
            sts=TRUE    ;Force an error
        endusing

        ;Hard close the cursor
        xcall ssc_close(iddb_channel, idf_customer)
    end

    freturn (.not.sts)

.end

;-------------------------------------------------------------------------------
;Routine:       get_group
;
;Description:   Read a group record
;
.function get_group, ^val

    .include "PRODUCT_GROUP" repository, group="product_group"
    a_lock      ,n
    ;End of parameters

.define TKAPP_INCLUDE
.include "SRC:tkapp.dbl"

stack record ivars
    sts         ,i4

stack record avars
    msg         ,a255       ;database error message

.define D_GET_GROUP "SELECT * FROM PRODUCT_GROUP WHERE NAME=:1"

.proc

    clear ^i(ivars), avars

    if(TRUE)
    begin
        ;open a cursor
        if (sts=%ssc_open(iddb_channel, idf_group ,
        &   D_GET_GROUP ,
        &   SSQL_SELECT, SSQL_STANDARD,
        &   1, product_group.name) .ne. SSQL_NORMAL) exit

        ;bind the command
        if (sts=%ssc_define(iddb_channel, idf_group, 2
        &   ,product_group.name
        &   ,product_group.description) .ne. SSQL_NORMAL) exit

        using (sts=%ssc_move(iddb_channel, idf_group)) select
        (SSQL_NORMAL),
            sts=FALSE   ;got a record, reverts to true on exit!
        (),
            sts=TRUE    ;force an error
        endusing
        ;hard close the cursor
        xcall ssc_close(iddb_channel, idf_group)
    end

    freturn (.not.sts)

.end

;-------------------------------------------------------------------------------
;Routine:       get_product
;
;Description:   Read a product record
;
.function get_product, ^val

    .include "PRODUCT" repository, group="product"
    a_lock      ,n
    ;End of parameters

.define TKAPP_INCLUDE
.include "SRC:tkapp.dbl"

stack record ivars
    sts         ,i4

stack record avars
    msg         ,a255       ;database error message

.define D_GET_PRODUCT "SELECT * FROM PRODUCT WHERE SKU=:1"

.proc

    clear ^i(ivars), avars

    if(TRUE)
    begin
        ;open a cursor
        if (sts=%ssc_open(iddb_channel, idf_product ,
        &   D_GET_PRODUCT ,
        &   SSQL_SELECT, SSQL_STANDARD,
        &   1, product.sku) .ne. SSQL_NORMAL) exit

        ;bind the command
        if (sts=%ssc_define(iddb_channel, idf_product, 18
        &   ,sku
        &   ,group
        &   ,description
        &   ,price_group
        &   ,selling_price
        &   ,last_sale
        &   ,last_cost_price
        &   ,moving_ave_cost_price
        &   ,qty_in_stock
        &   ,qty_allocated
        &   ,qty_in_transit
        &   ,qty_on_order
        &   ,reference
        &   ,publisher
        &   ,author
        &   ,type
        &   ,release_date
        &   ,rating) .ne. SSQL_NORMAL) exit

        using (sts=%ssc_move(iddb_channel, idf_product)) select
        (SSQL_NORMAL),
            sts=FALSE   ;got a record, reverts to true on exit!
        (),
            sts=TRUE    ;force an error
        endusing
        ;hard close the cursor
        xcall ssc_close(iddb_channel, idf_product)
    end

    freturn (.not.sts)

.end

;-------------------------------------------------------------------------------
;Routine:       get_user
;
;Description:   Read a user record
;
.function get_user, ^val

    .include "USER" repository, group="user"
    a_lock      ,n      ;lock ignored under SQL
    ;End of parameters

.define TKAPP_INCLUDE
.include "SRC:tkapp.dbl"

.include "USER" repository, stack record="tmpuser", nofields

stack record ivars
    sts         ,i4     ;function return status

stack record avars
    msg         ,a255   ;database error details

.define D_GET_USERTABLE "SELECT * FROM USERTABLE WHERE USERNAME=:1"

.proc

    clear ^i(ivars), avars

    if(TRUE)
    begin
        ;open a cursor
        if (sts=%ssc_open(iddb_channel, idf_user ,
        &   D_GET_USERTABLE ,
        &   SSQL_SELECT, SSQL_STANDARD,
        &   1, user.username) .ne. SSQL_NORMAL) exit

        ;bind the command
        if (sts=%ssc_define(iddb_channel, idf_user, 8
        &   ,user.username
        &   ,user.first_name
        &   ,user.last_name
        &   ,user.password
        &   ,user.user_customer
        &   ,user.phone_area
        &   ,user.phone_number
        &   ,user.email) .ne. SSQL_NORMAL) exit

        using (sts=%ssc_move(iddb_channel, idf_user)) select
        (SSQL_NORMAL),
            sts=FALSE   ;got a record, reverts to true on exit!
        (),
            sts=TRUE    ;force an error
        endusing
        ;hard close the cursor
        xcall ssc_close(iddb_channel, idf_user)

    end

    if (sts==SSQL_FAILURE)
    begin
        xcall ssc_getemsg(iddb_channel, msg, sts)
        xcall u_message(msg(1:sts))
    end

    freturn (.not.sts)

.end

;-------------------------------------------------------------------------------
;Routine:       get_next_customer
;
;Description:   Read next customer record
;
.function get_next_customer, ^val

    .include "CUSTOMER" repository, group="customer"
    a_lock      ,n
    ;End of parameters

.define TKAPP_INCLUDE
.include "SRC:tkapp.dbl"

stack record ivars
    sts         ,i4

stack record avars
    msg         ,a255

.proc

    clear ^i(ivars), avars

    ;Retrieve the next available row
    using (sts=%ssc_move(iddb_channel, idf_customer)) select
    (SSQL_NOMORE),
    begin
        ;Hard close the cursor
        if (sts=%ssc_close(iddb_channel, idf_customer).ne.SSQL_NORMAL) exit
        sts=TRUE    ;force EOF
    end
    (SSQL_FAILURE),
    begin
        xcall ssc_getemsg(iddb_channel, msg, sts)
        xcall u_message(msg(1:sts))
        xcall syn_reportevent(D_EVENTLOG_ERROR_TYPE, msg)
        sts=FALSE   ;force ERROR
    end
    endusing

    freturn (.not.sts)

.end

;-------------------------------------------------------------------------------
;Routine:       get_next_group
;
;Description:   Read next group record
;
.function get_next_group, ^val

    .include "PRODUCT_GROUP" repository, group="product_group"
    a_lock      ,n
    ;End of parameters

.define TKAPP_INCLUDE
.include "SRC:tkapp.dbl"

stack record ivars
    sts         ,i4

stack record avars
    msg         ,a255

.proc

    clear ^i(ivars), avars

    using (sts=%ssc_move(iddb_channel, idf_group)) select
    (SSQL_NOMORE),
    begin
        ;hard close the cursor
        if (sts=%ssc_close(iddb_channel, idf_group) .ne. SSQL_NORMAL) exit
        sts=TRUE    ;force EOF
    end
    (SSQL_FAILURE),
    begin
        xcall ssc_getemsg(iddb_channel, msg, sts)
        xcall u_message(msg(1:sts))
        xcall syn_reportevent(D_EVENTLOG_ERROR_TYPE, msg)
        sts=FALSE   ;force ERROR
    end
    endusing

    freturn (.not.sts)

.end

;-------------------------------------------------------------------------------
;Routine:       get_next_product
;
;Description:   Read next product record
;
.function get_next_product, ^val

    .include "PRODUCT" repository, group="product"
    a_lock      ,n
    ;End of parameters

.define TKAPP_INCLUDE
.include "SRC:tkapp.dbl"

stack record ivars
    sts         ,i4

stack record avars
    msg         ,a255

.proc

    clear ^i(ivars), avars

    using (sts=%ssc_move(iddb_channel, idf_product)) select
    (SSQL_NOMORE),
    begin
        ;hard close the cursor
        if (sts=%ssc_close(iddb_channel, idf_product) .ne. SSQL_NORMAL) exit
        sts=TRUE    ;force EOF
    end
    (SSQL_FAILURE),
    begin
        xcall ssc_getemsg(iddb_channel, msg, sts)
        xcall u_message(msg(1:sts))
        xcall syn_reportevent(D_EVENTLOG_ERROR_TYPE, msg)
        sts=FALSE   ;force ERROR
    end
    endusing

    freturn (.not.sts)

.end

;-------------------------------------------------------------------------------
;Routine:       get_next_user
;
;Description:   Read next user record
;
.function get_next_user, ^val

    .include "USER" repository, group="user"
    a_lock      ,n
    ;End of parameters

.define TKAPP_INCLUDE
.include "SRC:tkapp.dbl"

stack record ivars
    sts         ,i4

stack record avars
    msg         ,a255

.proc

    clear ^i(ivars), avars

    using (sts=%ssc_move(iddb_channel, idf_user)) select
    (SSQL_NOMORE),
    begin
        ;hard close the cursor
        if (sts=%ssc_close(iddb_channel, idf_user) .ne. SSQL_NORMAL) exit
        sts=TRUE    ;force EOF
    end
    (SSQL_FAILURE),
    begin
        xcall ssc_getemsg(iddb_channel, msg, sts)
        xcall u_message(msg(1:sts))
        xcall syn_reportevent(D_EVENTLOG_ERROR_TYPE, msg)
        sts=FALSE   ;force ERROR
    end
    endusing

    freturn (.not.sts)

.end

;-------------------------------------------------------------------------------
;Routine:       open_customer
;
;Description:   Open the customer file
;
.function open_customer, ^val

.define TKAPP_INCLUDE
.include "SRC:tkapp.dbl"

stack record ivars
    sts         ,i4

.proc

    ;Initialize local data
    clear ^i(ivars)

    ;Connect to database if not already connected
    sts = TRUE
    if (.not.iddb_channel)
        sts = %initialize_database

    freturn sts

.end

;-------------------------------------------------------------------------------
;Routine:       open_group
;
;Description:   Open the product group file
;
.function open_group, ^val

.define TKAPP_INCLUDE
.include "SRC:tkapp.dbl"

stack record ivars
    sts         ,i4

.proc

    clear ^i(ivars)

    sts = TRUE ; Success

    if (.not.iddb_channel)
        sts = %initialize_database

    freturn sts

.end

;-------------------------------------------------------------------------------
;Routine:       open_order
;
;Description:   Open the order file
;
.function open_order, ^val

.define TKAPP_INCLUDE
.include "SRC:tkapp.dbl"

stack record ivars
    sts         ,i4

.proc

    clear ^i(ivars)

    sts = TRUE ;Success

    if (.not.iddb_channel)
        sts = %initialize_database

    freturn sts

.end

;-------------------------------------------------------------------------------
;Routine:       open_orderline
;
;Description:   Open the order line items file
;
.function open_orderline, ^val

.define TKAPP_INCLUDE
.include "SRC:tkapp.dbl"

stack record ivars
    sts         ,i4

.proc

    clear ^i(ivars)

    sts = TRUE ;Success

    if (.not.iddb_channel)
        sts = %initialize_database

    freturn sts

.end

;-------------------------------------------------------------------------------
;Routine:       open_product
;
;Description:   Open the product file
;
.function open_product, ^val

.define TKAPP_INCLUDE
.include "SRC:tkapp.dbl"

stack record ivars
    sts         ,i4

.proc

    clear ^i(ivars)

    sts = TRUE ; Success

    if (.not.iddb_channel)
        sts = %initialize_database

    freturn sts

.end

;-------------------------------------------------------------------------------
;Routine:       open_user
;
;Description:   Open the user file
;
.function open_user, ^val

.define TKAPP_INCLUDE
.include "SRC:tkapp.dbl"

stack record ivars
    sts         ,i4

.proc

    clear ^i(ivars)

    sts=TRUE ;default

    if (.not.iddb_channel)
        sts = %initialize_database

    freturn sts

.end

;-------------------------------------------------------------------------------
;Routine:       update_customer
;
;Description:   Update an existing customer record
;
.function update_customer, ^val

    .include "CUSTOMER" repository, group="a_customer"
    ;End of parameters

.define TKAPP_INCLUDE
.include "SRC:tkapp.dbl"

stack record ivars
    sts         ,i4

stack record avars
    msg         ,a255

;Define the SQL UPDATE statement
.define D_UPDATE_CUSTOMER "UPDATE CUSTOMER SET "
&   + "ACCOUNT=:1,"
&   + "COMPANY=:2,"
&   + "STREET_NUMBER=:3,"
&   + "STREET=:4,"
&   + "CITY=:5,"
&   + "REGION=:6,"
&   + "POSTAL_CODE=:7,"
&   + "COUNTRY=:8,"
&   + "PHONE_COUNTRY=:9,"
&   + "PHONE_AREA=:10,"
&   + "PHONE_NUMBER=:11,"
&   + "FAX_AREA=:12,"
&   + "FAX_NUMBER=:13,"
&   + "MOBILE_AREA=:14,"
&   + "MOBILE_NUMBER=:15,"
&   + "PAGER_AREA=:16,"
&   + "PAGER_NUMBER=:17,"
&   + "EMAIL1=:18,"
&   + "EMAIL2=:19,"
&   + "DATE_OPENED=:20,"
&   + "DATE_HOLD=:21,"
&   + "DATE_CLOSED=:22,"
&   + "STATUS=:23,"
&   + "LIMIT=:24,"
&   + "BALANCE=:25,"
&   + "CARD_NUMBER=:26,"
&   + "CARD_EXPIRY=:27,"
&   + "CARD_NAME=:28 WHERE ACCOUNT=:29"

.proc

    clear ^i(ivars), avars

    if(TRUE)
    begin
        ;Open a cursor
        if (sts=%ssc_open(iddb_channel, idf_customer, D_UPDATE_CUSTOMER,
        &   SSQL_NONSEL,SSQL_STANDARD) .ne. SSQL_NORMAL) exit

        ;Bind the command
        if (sts=%ssc_bind(iddb_channel, idf_customer, 29
        &       ,a_customer.account
        &       ,a_customer.company
        &       ,a_customer.number
        &       ,a_customer.street
        &       ,a_customer.city
        &       ,a_customer.region
        &       ,a_customer.postal_code
        &       ,a_customer.country
        &       ,a_customer.phone_country
        &       ,a_customer.phone_area
        &       ,a_customer.phone_number
        &       ,a_customer.fax_area
        &       ,a_customer.fax_number
        &       ,a_customer.mobile_area
        &       ,a_customer.mobile_number
        &       ,a_customer.pager_area
        &       ,a_customer.pager_number
        &       ,a_customer.email1
        &       ,a_customer.email2
        &       ,^a(a_customer.date_opened)
        &       ,^a(a_customer.date_hold)
        &       ,^a(a_customer.date_closed)
        &       ,a_customer.status
        &       ,a_customer.limit
        &       ,a_customer.balance
        &       ,a_customer.card_number
        &       ,a_customer.card_expiry
        &       ,a_customer.card_name
        &       ,a_customer.account) .ne. SSQL_NORMAL) exit

        ;Start a transaction
        if (sts=%ssc_commit(iddb_channel, SSQL_TXON).ne. SSQL_NORMAL) exit

        ;Check date values
        if (.not.date_opened)
            ^a(date_opened(1:1)) = %char(0)
        if (.not.date_hold)
            ^a(date_hold(1:1)) = %char(0)
        if (.not.date_closed)
            ^a(date_closed(1:1)) = %char(0)
        if (.not.card_expiry)
            ^a(card_expiry(1:1)) = %char(0)

        ;Execute the bound command
        if (sts=%ssc_execute(iddb_channel, idf_customer,
        &    SSQL_STANDARD) .ne. SSQL_NORMAL) exit

        ;Hard close the cursor
        if (sts=%ssc_close(iddb_channel, idf_customer).ne.SSQL_NORMAL) exit

        ;Commit the transaction
        if (sts=%ssc_commit(iddb_channel,SSQL_TXOFF) .ne. SSQL_NORMAL) exit

    end

    ;Report any database error
    if (sts)
    begin
        xcall ssc_getemsg(iddb_channel, msg, sts)
        xcall u_message(msg(1:sts))
        xcall syn_reportevent(D_EVENTLOG_ERROR_TYPE, msg)
        xcall ssc_rollback(iddb_channel, SSQL_TXOFF)
    end

    freturn (.not.sts)

.end

;-------------------------------------------------------------------------------
;Routine:       update_group
;
;Description:   Update an existing group record
;
.function update_group, ^val

    .include "PRODUCT_GROUP" repository, group="product_group"
    ;End of parameters

.define TKAPP_INCLUDE
.include "SRC:tkapp.dbl"

stack record ivars
    sts         ,i4

stack record avars
    msg         ,a255

.define D_UPDATE_GROUP "UPDATE PRODUCT_GROUP SET "
&       + "NAME=:1,"
&       + "DESCRIPTION=:2 WHERE NAME=:3"

.proc

    clear ^i(ivars), avars

    if(TRUE)
    begin
        ;open a cursor
        if (sts=%ssc_open(iddb_channel, idf_group ,
        &   D_UPDATE_GROUP,
        &   SSQL_NONSEL,SSQL_STANDARD) .ne. SSQL_NORMAL) exit

        ;bind the command
        if (sts=%ssc_bind(iddb_channel, idf_group, 3
        &   ,product_group.name
        &   ,product_group.description
        &   ,product_group.name) .ne. SSQL_NORMAL) exit

        ;start a transaction
        if (sts=%ssc_commit(iddb_channel, SSQL_TXON)  .ne.  SSQL_NORMAL) exit

        ;execute the bound command
        if (sts=%ssc_execute(iddb_channel, idf_group,
        &   SSQL_STANDARD) .ne. SSQL_NORMAL) exit

        ;hard close the idf_customer
        if (sts=%ssc_close(iddb_channel, idf_group) .ne. SSQL_NORMAL) exit

        ;commit the transaction
        if (sts=%ssc_commit(iddb_channel,SSQL_TXOFF) .ne. SSQL_NORMAL) exit

    end

    if (sts)
    begin
        xcall ssc_getemsg(iddb_channel, msg, sts)
        xcall u_message(msg(1:sts))
        xcall syn_reportevent(D_EVENTLOG_ERROR_TYPE, msg)
    end

    freturn (.not.sts)

.end

;-------------------------------------------------------------------------------
;Routine:       update_product
;
;Description:   Update an existing product record
;
.function update_product, ^val

    .include "PRODUCT" repository, group="product"
    ;End of parameters

.define TKAPP_INCLUDE
.include "SRC:tkapp.dbl"

stack record ivars
    sts         ,i4

stack record avars
    msg         ,a255

.define D_UPDATE_PRODUCT "UPDATE PRODUCT SET "
&       + "SKU=:1,"
&       + "PRODUCT_GROUP=:2,"
&       + "DESCRIPTION=:3,"
&       + "PRICE_GROUP=:4,"
&       + "SELLING_PRICE=:5,"
&       + "LAST_SALE=:6,"
&       + "LAST_COST_PRICE=:7,"
&       + "MOVING_AVE_COST_PRICE=:8,"
&       + "QTY_IN_STOCK=:9,"
&       + "QTY_ALLOCATED=:10,"
&       + "QTY_IN_TRANSIT=:11,"
&       + "QTY_ON_ORDER=:12,"
&       + "REFERENCE=:13,"
&       + "PUBLISHER=:14,"
&       + "AUTHOR=:15,"
&       + "PRODUCT_TYPE=:16,"
&       + "RELEASE_DATE=:17,"
&       + "RATING=:18 WHERE SKU=:19"

.proc

    clear ^i(ivars), avars

    if(TRUE)
    begin
        ;open a cursor
        if (sts=%ssc_open(iddb_channel, idf_product ,
        &   D_UPDATE_PRODUCT,
        &   SSQL_NONSEL,SSQL_STANDARD) .ne. SSQL_NORMAL) exit

        ;bind the command
        if (sts=%ssc_bind(iddb_channel, idf_product, 19
        &   ,sku
        &   ,group
        &   ,description
        &   ,price_group
        &   ,selling_price
        &   ,last_sale
        &   ,last_cost_price
        &   ,moving_ave_cost_price
        &   ,qty_in_stock
        &   ,qty_allocated
        &   ,qty_in_transit
        &   ,qty_on_order
        &   ,reference
        &   ,publisher
        &   ,author
        &   ,type
        &   ,release_date
        &   ,rating
        &   ,sku) .ne. SSQL_NORMAL) exit

        ;start a transaction
        if (sts=%ssc_commit(iddb_channel, SSQL_TXON)  .ne.  SSQL_NORMAL) exit

        ;Check date values
        if (.not.last_sale)
            ^a(last_sale(1:1)) = %char(0)
        if (.not.release_date)
            ^a(release_date(1:1)) = %char(0)

            ;execute the bound command
        if (sts=%ssc_execute(iddb_channel, idf_product,
        &   SSQL_STANDARD) .ne. SSQL_NORMAL) exit

        ;hard close the idf_customer
        if (sts=%ssc_close(iddb_channel, idf_product) .ne. SSQL_NORMAL) exit

        ;commit the transaction
        if (sts=%ssc_commit(iddb_channel,SSQL_TXOFF) .ne. SSQL_NORMAL) exit

    end

    if (sts)
    begin
        xcall ssc_getemsg(iddb_channel, msg, sts)
        xcall u_message(msg(1:sts))
        xcall syn_reportevent(D_EVENTLOG_ERROR_TYPE, msg)
    end

    freturn (.not.sts)

.end

;-------------------------------------------------------------------------------
;Routine:       update_user
;
;Description:   Update an existing user record
;
.function update_user, ^val

    .include "USER" repository, group="user"
    ;End of parameters

.define TKAPP_INCLUDE
.include "SRC:tkapp.dbl"

stack record ivars
    sts         ,i4

stack record avars
    msg             ,a255   ;database error message

;define the insert command
.define D_UPDATE_USERTABLE "UPDATE USERTABLE SET "
    &       + "USERNAME=:1,"
    &       + "FIRST_NAME=:2,"
    &       + "LAST_NAME=:3,"
    &       + "PASSWORD=:4,"
    &       + "USER_CUSTOMER=:5,"
    &       + "PHONE_AREA=:6,"
    &       + "PHONE_NUMBER=:7,"
    &       + "EMAIL=:8 WHERE USERNAME=:9"

.proc

    clear ^i(ivars), avars

    if (TRUE)
    begin
        ;open a cursor
        if (sts=%ssc_open(iddb_channel, idf_user ,
        &   D_UPDATE_USERTABLE,
        &   SSQL_NONSEL,SSQL_STANDARD) .ne. SSQL_NORMAL) exit

        ;bind the command
        if (sts=%ssc_bind(iddb_channel, idf_user, 9
        &   ,user.username
        &   ,user.first_name
        &   ,user.last_name
        &   ,user.password
        &   ,user.user_customer
        &   ,user.phone_area
        &   ,user.phone_number
        &   ,user.email
        &   ,user.username) .ne. SSQL_NORMAL) exit

        ;start a transaction
        if (sts=%ssc_commit(iddb_channel, SSQL_TXON)  .ne.  SSQL_NORMAL) exit

        ;execute the bound command
        if (sts=%ssc_execute(iddb_channel, idf_user,
        &   SSQL_STANDARD) .ne. SSQL_NORMAL) exit

        ;hard close the cursor
        if (sts=%ssc_close(iddb_channel, idf_user) .ne. SSQL_NORMAL) exit

        ;commit the transaction
        if (sts=%ssc_commit(iddb_channel,SSQL_TXOFF) .ne. SSQL_NORMAL) exit

    end

    if (sts)
    begin
        xcall ssc_getemsg(iddb_channel, msg, sts)
        xcall u_message(msg(1:sts))
        xcall syn_reportevent(D_EVENTLOG_ERROR_TYPE, msg)
    end

    freturn (.not.sts)

.end

;-------------------------------------------------------------------------------
;Routine:       release_customer
;
;Description:   Release (unlock) a customer record
;
.subroutine release_customer

    ;End of parameters

.define TKAPP_INCLUDE
.include "SRC:tkapp.dbl"

.proc


    xreturn

.end

;-------------------------------------------------------------------------------
;Routine:       release_group
;
;Description:   Release (unlock) a group record
;
.subroutine release_group

    ;End of parameters

.define TKAPP_INCLUDE
.include "SRC:tkapp.dbl"

.proc


    xreturn

.end

;-------------------------------------------------------------------------------
;Routine:       release_product
;
;Description:   Release (unlock) a product record
;
.subroutine release_product

    ;End of parameters

.define TKAPP_INCLUDE
.include "SRC:tkapp.dbl"

.proc


    xreturn

.end

;-------------------------------------------------------------------------------
;Routine:       release_user
;
;Description:   Release (unlock) a user record
;
.subroutine release_user

    ;End of parameters

.define TKAPP_INCLUDE
.include "SRC:tkapp.dbl"

.proc


    xreturn

.end
;-------------------------------------------------------------------------------
;Routine:       close_customer
;
;Description:   close the customer file
;
.function close_customer, ^val

.define TKAPP_INCLUDE
.include "SRC:tkapp.dbl"

stack record ivars
    sts         ,i4

.proc

    clear ^i(ivars)

    sts = TRUE ; Success

    ;Close the database connection
    if (iddb_channel)
    begin
        xcall ssc_release(iddb_channel)
        clear iddb_channel
    end

    freturn sts

.end

;-------------------------------------------------------------------------------
;Routine:       close_group
;
;Description:   close the product group file
;
.function close_group, ^val

.define TKAPP_INCLUDE
.include "SRC:tkapp.dbl"

stack record ivars
    sts         ,i4

.proc

    clear ^i(ivars)

    sts = TRUE ; Success

    if (iddb_channel)
    begin
        xcall ssc_release(iddb_channel)
        clear iddb_channel
    end

    freturn sts

.end

;-------------------------------------------------------------------------------
;Routine:       close_order
;
;Description:   close the order file
;
.function close_order, ^val

.define TKAPP_INCLUDE
.include "SRC:tkapp.dbl"

stack record ivars
    sts         ,i4

.proc

    clear ^i(ivars)

    sts = TRUE ;Success

    if (iddb_channel)
    begin
        xcall ssc_release(iddb_channel)
        clear iddb_channel
    end

    freturn sts

.end

;-------------------------------------------------------------------------------
;Routine:       close_orderline
;
;Description:   close the order line items file
;
.function close_orderline, ^val

.define TKAPP_INCLUDE
.include "SRC:tkapp.dbl"

stack record ivars
    sts         ,i4

.proc

    clear ^i(ivars)

    sts = TRUE ;Success

    if (iddb_channel)
    begin
        xcall ssc_release(iddb_channel)
        clear iddb_channel
    end

    freturn sts

.end

;-------------------------------------------------------------------------------
;Routine:       close_product
;
;Description:   close the product file
;
.function close_product, ^val

.define TKAPP_INCLUDE
.include "SRC:tkapp.dbl"

stack record ivars
    sts         ,i4

.proc

    clear ^i(ivars)

    sts = TRUE ; Success

    if (iddb_channel)
    begin
        xcall ssc_release(iddb_channel)
        clear iddb_channel
    end

    freturn sts

.end

;-------------------------------------------------------------------------------
;Routine:       close_user
;
;Description:   close the user file
;
.function close_user, ^val

.define TKAPP_INCLUDE
.include "SRC:tkapp.dbl"

stack record ivars
    sts         ,i4

.proc

    clear ^i(ivars)

    sts=TRUE ;default

    if (iddb_channel)
    begin
        xcall ssc_release(iddb_channel)
        clear iddb_channel
    end

    freturn sts

.end

;-------------------------------------------------------------------------------
;Routine:       order_save
;
;Description:   Save order details
;
.function order_save, ^val

    .include "ORDER_HEADER" repository, group="oheader"     ;Order header record
    a_odetail_count     ,n                                  ;# of detail records
    a_odetail_handle    ,n                                  ;Detail records
    ;End of argument list

.include "CONNECTDIR:ssql.def"
.define TKAPP_INCLUDE
.include "SRC:tkapp.dbl"

.include "ORDER_LINE" repository, structure = "odetail"
.include "ORDER_LINE" repository, stack record = "tmpodetail"

.align
stack record ivars
    od_number   ,i4     ;next available order number
    sts         ,i4     ;status
    len         ,i4     ;message length
    count       ,i4     ;counter
    sp_cursor   ,i4     ;stored procedure cursor
    oh_cursor   ,i4     ;order header cursor
    od_cursor   ,i4     ;order line cursor

stack record avars
    msg             ,a255   ;error details

;Define the execute stored procedure statement
.define D_EXECUTE_STORED_PROC "{CALL GET_NEXT_ORDER_NUMBER (:1)}"

;Define the order header insert command
.define D_INSERT_ORDER_HEAD "INSERT INTO ORDER_HEADER("
&   + "ORDER_NUMBER,"
&   + "ORDER_DATE,"
&   + "STATUS,"
&   + "SHIP_DATE,"
&   + "CUSTOMER,"
&   + "DELIVERY_DATE,"
&   + "CUSTOMER_ORDER_REF,"
&   + "GOODS_VALUE,"
&   + "TAX_VALUE,"
&   + "SHIPPING_VALUE,"
&   + "GIFT_WRAP,"
&   + "GIFT_MESSAGE)"

.define D_ORDER_HEAD_VALUES " VALUES(:1,:2,:3,:4,:5,"
&       ":6,:7,:8,:9,:10,:11,:12)"

;Define the order detail insert command
.define D_INSERT_ORDER_LINE "INSERT INTO ORDER_LINE("
&   + "ORDER_NUMBER,"
&   + "LINE_NUMBER,"
&   + "SKU,"
&   + "DESCRIPTION,"
&   + "QTY_ORDERED,"
&   + "QTY_ALLOCATED,"
&   + "PRICE,"
&   + "LINE_VALUE,"
&   + "TAX)"

.define D_ORDER_LINE_VALUES " VALUES(:1,:2,:3,:4,:5,:6,:7,:8,:9)"

.proc

    clear ^i(ivars)

    ;Call the stored procedure to retreive the next order number

    if (TRUE)
    begin
        ;Open a cursor for the stored procedure
        if (sts = %ssc_open(iddb_channel, sp_cursor,D_EXECUTE_STORED_PROC,SSQL_NONSEL) .ne. SSQL_NORMAL) exit

        ;Execute the stored procedure
        if (sts = %ssc_execio(iddb_channel, sp_cursor, 1, 1, SSQL_OUTPUT, od_number, "@retval").ne.SSQL_NORMAL) exit

        ;Hard close the stored procedure cursor
        if (sts=%ssc_close(iddb_channel, sp_cursor) .ne. SSQL_NORMAL) exit

        ;Fill header and detail fields
        call fill_order_details

        ;Start a transaction
        if (sts=%ssc_commit(iddb_channel, SSQL_TXON) .ne. SSQL_NORMAL) exit

        ;Open a cursor to insert the order header
        if (sts=%ssc_open(iddb_channel, oh_cursor ,
        &   D_INSERT_ORDER_HEAD + D_ORDER_HEAD_VALUES,
        &   SSQL_NONSEL,SSQL_STANDARD) .ne. SSQL_NORMAL) exit

        ;Bind the order header fields
        if (sts=%ssc_bind(iddb_channel, oh_cursor, 12
        &   ,oheader.order
        &   ,^a(oheader.order_date)
        &   ,oheader.status
        &   ,^a(oheader.ship_date)
        &   ,oheader.customer
        &   ,^a(oheader.delivery_date)
        &   ,oheader.customer_order_ref
        &   ,oheader.goods_value
        &   ,oheader.tax_value
        &   ,oheader.shipping_value
        &   ,oheader.gift_wrap
        &   ,oheader.gift_message) .ne. SSQL_NORMAL) exit

        ;Check the dates
        if (.not.ship_date)
            ^a(ship_date(1:1)) = %char(0)
        if (.not.delivery_date)
            ^a(delivery_date(1:1)) = %char(0)

        ;Execute the bound command
        if (sts=%ssc_execute(iddb_channel, oh_cursor,
        &   SSQL_STANDARD) .ne. SSQL_NORMAL) exit

        ;Hard close the order header cursor
        if (sts=%ssc_close(iddb_channel, oh_cursor) .ne. SSQL_NORMAL) exit

        ;Open the cursor to insert the order details
        if (sts=%ssc_open(iddb_channel, od_cursor ,
        &   D_INSERT_ORDER_LINE + D_ORDER_LINE_VALUES,
        &   SSQL_NONSEL,SSQL_STANDARD) .ne. SSQL_NORMAL) exit

        ;Bind the order line fields
        if (sts=%ssc_bind(iddb_channel, od_cursor, 9
        &   ,tmpodetail.order
        &   ,tmpodetail.line_number
        &   ,tmpodetail.sku
        &   ,tmpodetail.description
        &   ,tmpodetail.qty_ordered
        &   ,tmpodetail.qty_allocated
        &   ,tmpodetail.price
        &   ,tmpodetail.line_value
        &   ,tmpodetail.tax) .ne. SSQL_NORMAL) exit

        ;Execute the line insert multiple times
        for count from 1 thru a_odetail_count
        begin
            tmpodetail = ^m(odetail[count],a_odetail_handle)
            if (sts=%ssc_execute(iddb_channel, od_cursor,
            &   SSQL_STANDARD) .ne. SSQL_NORMAL) exit
        end

        ;Hard close the line cursor
        if (sts=%ssc_close(iddb_channel, od_cursor) .ne. SSQL_NORMAL) exit

        ;Commit the transaction
        if (sts=%ssc_commit(iddb_channel,SSQL_TXOFF) .ne. SSQL_NORMAL) exit

    end

    ;Report any database error
    if sts
    begin
        xcall ssc_getemsg(iddb_channel, msg, len)
        xcall u_message(msg(1:len))
        xcall syn_reportevent(D_EVENTLOG_ERROR_TYPE, msg)
    end

    freturn (.not.sts)

fill_order_details,

    ;Populate order number fields

    oheader.order=od_number

    for count from 1 thru a_odetail_count
    begin
        ^m(odetail[count].order, a_odetail_handle) = od_number
        ^m(odetail[count].line_number, a_odetail_handle) = count
    end

    return

.end

